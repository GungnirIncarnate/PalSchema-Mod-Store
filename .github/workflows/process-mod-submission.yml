name: Process Mod Submission

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process-submission:
    if: |
      (github.event_name == 'issues' && (
        contains(github.event.issue.labels.*.name, 'mod-submission') ||
        contains(github.event.issue.title, '[MOD SUBMISSION]') ||
        contains(github.event.issue.title, 'MOD SUBMISSION')
      )) || 
      (github.event_name == 'issue_comment' && contains(github.event.issue.labels.*.name, 'mod-submission'))
    runs-on: ubuntu-latest
    
    steps:
      - name: Debug event information
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Event action: ${{ github.event.action }}"
          echo "Issue title: ${{ github.event.issue.title }}"
          echo "Issue labels: ${{ toJson(github.event.issue.labels) }}"
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "Issue event detected"
            echo "Label name: ${{ github.event.label.name }}"
          fi
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            echo "Comment event detected"
            echo "Comment body: ${{ github.event.comment.body }}"
          fi
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      
      - name: Parse mod submission
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body;
            
            // Parse the issue body to extract mod information
            const parseField = (fieldName) => {
              const regex = new RegExp(`### ${fieldName}\\s*([\\s\\S]*?)(?=###|$)`);
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };
            
            const modInfo = {
              name: parseField('Mod Name') || parseField('ModName'),
              version: parseField('Version'),
              description: parseField('Description'),
              author: parseField('Author'),
              tags: parseField('Tags'),
              minGameVersion: parseField('Minimum Game Version'),
              homepage: parseField('Homepage'),
              sourceCode: parseField('Source Code'),
              modDownloadUrl: parseField('Mod ZIP File Download URL'),
              iconDownloadUrl: parseField('Icon Download URL')
            };
            
            // Create folder name from mod name
            const folderName = modInfo.name.replace(/[^a-zA-Z0-9]/g, '');
            
            core.setOutput('mod-name', modInfo.name);
            core.setOutput('folder-name', folderName);
            core.setOutput('version', modInfo.version);
            core.setOutput('description', modInfo.description);
            core.setOutput('author', modInfo.author);
            core.setOutput('mod-download-url', modInfo.modDownloadUrl);
            core.setOutput('icon-download-url', modInfo.iconDownloadUrl);
            core.setOutput('issue-number', issue.number);
            
            return modInfo;
      
      - name: Create mod structure (manual approval)
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          # This would be triggered by a maintainer comment "/approve-mod"
          echo "ğŸ”§ Creating mod structure for: ${{ steps.parse.outputs.mod-name }}"
          
          # Create mod directory
          mkdir -p "mods/${{ steps.parse.outputs.folder-name }}"
          
          # Create mod-info.json
          cat > "mods/${{ steps.parse.outputs.folder-name }}/mod-info.json" << 'EOF'
          {
            "ModName": "${{ steps.parse.outputs.mod-name }}",
            "Version": "${{ steps.parse.outputs.version }}",
            "Description": "${{ steps.parse.outputs.description }}",
            "Author": "${{ steps.parse.outputs.author }}",
            "Tags": ["pending"],
            "MinGameVersion": "0.3.0"
          }
          EOF
          
          echo "ğŸ“ Mod structure created."
      
      - name: Download mod files
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          MOD_FOLDER="mods/${{ steps.parse.outputs.folder-name }}"
          MOD_ZIP_URL="${{ steps.parse.outputs.mod-download-url }}"
          ICON_URL="${{ steps.parse.outputs.icon-download-url }}"
          
          echo "ğŸ“¥ Downloading mod files..."
          
          # Function to convert Google Drive URLs to direct download
          convert_gdrive_url() {
            local url="$1"
            
            # Check if it's a Google Drive URL
            if [[ "$url" == *"drive.google.com"* ]]; then
              echo "ğŸ”„ Converting Google Drive URL to direct download..."
              
              # Extract file ID from various Google Drive URL formats
              FILE_ID=""
              if [[ "$url" == *"/file/d/"* ]]; then
                # Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
                FILE_ID=$(echo "$url" | sed -n 's/.*\/file\/d\/\([^\/]*\).*/\1/p')
              elif [[ "$url" == *"id="* ]]; then
                # Format: https://drive.google.com/open?id=FILE_ID
                FILE_ID=$(echo "$url" | sed -n 's/.*id=\([^&]*\).*/\1/p')
              fi
              
              if [ ! -z "$FILE_ID" ]; then
                echo "ğŸ“ Google Drive File ID: $FILE_ID"
                echo "https://drive.google.com/uc?export=download&id=$FILE_ID"
              else
                echo "âš ï¸ Could not extract Google Drive file ID, using original URL"
                echo "$url"
              fi
            else
              echo "$url"
            fi
          }
          
          # Download mod ZIP file
          if [ ! -z "$MOD_ZIP_URL" ] && [ "$MOD_ZIP_URL" != "null" ]; then
            echo "Downloading mod ZIP from: $MOD_ZIP_URL"
            
            # Convert Google Drive URL if needed
            DOWNLOAD_URL=$(convert_gdrive_url "$MOD_ZIP_URL")
            echo "Using download URL: $DOWNLOAD_URL"
            
            # Extract filename from URL or create one
            ZIP_FILENAME=$(basename "$MOD_ZIP_URL")
            if [[ "$ZIP_FILENAME" != *.zip ]] || [[ "$ZIP_FILENAME" == *"?"* ]]; then
              ZIP_FILENAME="${{ steps.parse.outputs.folder-name }}-v${{ steps.parse.outputs.version }}.zip"
            fi
            
            echo "Saving as: $ZIP_FILENAME"
            
            # Download with enhanced options for Google Drive
            DOWNLOAD_SUCCESS=false
            if command -v wget &> /dev/null; then
              echo "Using wget for download..."
              wget --no-check-certificate --load-cookies /tmp/cookies.txt \
                   "https://docs.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://docs.google.com/uc?export=download&id='$(echo "$DOWNLOAD_URL" | sed -n 's/.*id=\([^&]*\).*/\1/p') -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\1\n/p')&id=$(echo "$DOWNLOAD_URL" | sed -n 's/.*id=\([^&]*\).*/\1/p')" \
                   -O "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null && DOWNLOAD_SUCCESS=true
              
              # Fallback to simple wget if the complex method fails
              if [ "$DOWNLOAD_SUCCESS" = false ]; then
                echo "Fallback to simple wget..."
                wget -O "$MOD_FOLDER/$ZIP_FILENAME" "$DOWNLOAD_URL" 2>/dev/null && DOWNLOAD_SUCCESS=true
              fi
            elif command -v curl &> /dev/null; then
              echo "Using curl for download..."
              curl -L -o "$MOD_FOLDER/$ZIP_FILENAME" "$DOWNLOAD_URL" 2>/dev/null && DOWNLOAD_SUCCESS=true
            else
              echo "âŒ Neither wget nor curl available for download"
            fi
            
            # Verify download
            if [ -f "$MOD_FOLDER/$ZIP_FILENAME" ] && [ "$DOWNLOAD_SUCCESS" = true ]; then
              FILE_SIZE=$(stat -c%s "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null || stat -f%z "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null || echo "0")
              
              # Check if we downloaded a virus warning page instead of actual file
              if [ "$FILE_SIZE" -lt 10000 ] && grep -q "virus" "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null; then
                echo "âš ï¸ Downloaded virus warning page instead of file. File may be too large for automatic download."
                echo "ğŸ“ Please use a direct download link or upload to GitHub releases instead of Google Drive."
                rm -f "$MOD_FOLDER/$ZIP_FILENAME"
              else
                echo "âœ… Mod ZIP downloaded successfully ($FILE_SIZE bytes)"
              fi
            else
              echo "âŒ Mod ZIP download failed"
            fi
          else
            echo "âš ï¸ No mod ZIP URL provided"
          fi
          
          # Download icon file
          if [ ! -z "$ICON_URL" ] && [ "$ICON_URL" != "null" ]; then
            echo "Downloading icon from: $ICON_URL"
            
            # Convert Google Drive URL if needed
            ICON_DOWNLOAD_URL=$(convert_gdrive_url "$ICON_URL")
            
            # Extract extension from URL
            ICON_EXT="${ICON_URL##*.}"
            case "$ICON_EXT" in
              png|jpg|jpeg|gif|webp) ICON_FILENAME="icon.$ICON_EXT" ;;
              *) ICON_FILENAME="icon.png" ;;
            esac
            
            # Download icon
            if command -v wget &> /dev/null; then
              wget --no-check-certificate -O "$MOD_FOLDER/$ICON_FILENAME" "$ICON_DOWNLOAD_URL" || echo "âš ï¸ Failed to download icon (optional)"
            elif command -v curl &> /dev/null; then
              curl -L -o "$MOD_FOLDER/$ICON_FILENAME" "$ICON_DOWNLOAD_URL" || echo "âš ï¸ Failed to download icon (optional)"
            fi
            
            # Verify icon download
            if [ -f "$MOD_FOLDER/$ICON_FILENAME" ]; then
              ICON_SIZE=$(stat -c%s "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null || stat -f%z "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null || echo "0")
              
              # Check if we downloaded a virus warning page for icon too
              if [ "$ICON_SIZE" -lt 1000 ] && grep -q "virus" "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null; then
                echo "âš ï¸ Icon download got virus warning page (file too large). Skipping icon."
                rm -f "$MOD_FOLDER/$ICON_FILENAME"
              else
                echo "âœ… Icon downloaded successfully ($ICON_SIZE bytes)"
              fi
            else
              echo "âš ï¸ Icon download failed (optional file)"
            fi
          else
            echo "â„¹ï¸ No icon URL provided (optional)"
          fi
          
          echo "ğŸ“ Download process completed"
      
      - name: Commit mod structure
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Bot"
          git add "mods/${{ steps.parse.outputs.folder-name }}/"
          git commit -m "âœ… Add approved mod with files: ${{ steps.parse.outputs.mod-name }} v${{ steps.parse.outputs.version }} (Issue #${{ steps.parse.outputs.issue-number }})"
          git push
          echo "ğŸš€ Mod structure committed and pushed to repository"
      
      - name: Update manifest
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          echo "ğŸ”„ Updating manifest with new mod..."
          python scripts/generate-manifest.py
          
          # Check if manifest changed
          if git diff --quiet manifest.json; then
            echo "â„¹ï¸ No manifest changes needed"
          else
            echo "ğŸ“ Manifest updated, committing changes..."
            git add manifest.json
            git commit -m "ğŸ¤– Auto-update manifest after adding ${{ steps.parse.outputs.mod-name }}"
            git push
            echo "âœ… Manifest updated and pushed"
          fi
      
      - name: Add approval comment
        if: contains(github.event.comment.body, '/approve-mod')
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **Mod Approved and Fully Processed!**
              
              **${{ steps.parse.outputs.mod-name }}** has been approved and automatically added to the mod store!
              
              **ğŸ“ Mod Location:** \`mods/${{ steps.parse.outputs.folder-name }}/\`
              
              **ğŸ“¥ Files Downloaded:**
              - âœ… Mod metadata (mod-info.json)
              - ğŸ“¦ Mod ZIP file (automatically downloaded)
              - ğŸ–¼ï¸ Icon file (if provided)
              
              **Next Steps:**
              1. ğŸ”„ Manifest will be updated automatically
              2. âœ… Mod will be available in mod managers within 15 minutes
              3. ğŸ‰ Users can now download and install your mod!
              
              **Download URLs used:**
              - **Mod ZIP:** ${{ steps.parse.outputs.mod-download-url }}
              - **Icon:** ${{ steps.parse.outputs.icon-download-url }}
              
              Your mod is now live in the PalSchema Mod Store! Thank you for contributing! ğŸš€`
            });
      
      - name: Add processing comment
        if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'opened')
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ğŸ® **Mod Submission Received!**
              
              Thank you for submitting **${{ steps.parse.outputs.mod-name }}** to the PalSchema Mod Store!
              
              **Next Steps:**
              1. ğŸ” Our team will review your submission
              2. ğŸ§ª We'll test the mod for compatibility and safety
              3. âœ… If approved, your mod will be added to the store
              
              **For Maintainers:**
              - Review the mod details above
              - Download and test the mod files:
                - **Mod ZIP:** ${{ steps.parse.outputs.mod-download-url }}
                - **Icon:** ${{ steps.parse.outputs.icon-download-url }}
              - Comment \`/approve-mod\` to process this submission
              - Comment \`/reject-mod [reason]\` to reject with explanation
              
              **Estimated Review Time:** 2-5 business days
              
              **ğŸ“ Note for large files:** If using Google Drive, large files may trigger virus warnings that prevent automatic download. For best results, consider using:
              - GitHub Releases (recommended)
              - Direct links from your own server
              - Other file hosting services with direct download support
              
              We'll keep you updated on the status! ğŸš€`
            });
      
      - name: Handle rejection
        if: contains(github.event.comment.body, '/reject-mod')
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const reason = comment.replace('/reject-mod', '').trim();
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âŒ **Mod Submission Rejected**
              
              Unfortunately, we cannot accept **${{ steps.parse.outputs.mod-name }}** at this time.
              
              **Reason:** ${reason || 'No reason provided'}
              
              **What you can do:**
              - Address the issues mentioned above
              - Submit a new mod submission with the fixes
              - Join our Discord for help and discussion
              
              Thank you for your contribution! ğŸ™`
            });
            
            // Close the issue
            github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['mod-submission', 'rejected']
            });