name: Process Mod Submission

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process-submission:
    if: |
      (github.event_name == 'issues' && (
        contains(github.event.issue.labels.*.name, 'mod-submission') ||
        contains(github.event.issue.title, '[MOD SUBMISSION]') ||
        contains(github.event.issue.title, 'MOD SUBMISSION')
      )) || 
      (github.event_name == 'issue_comment' && contains(github.event.issue.labels.*.name, 'mod-submission'))
    runs-on: ubuntu-latest
    
    steps:
      - name: Debug event information
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Event action: ${{ github.event.action }}"
          echo "Issue title: ${{ github.event.issue.title }}"
          echo "Issue labels: ${{ toJson(github.event.issue.labels) }}"
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "Issue event detected"
            echo "Label name: ${{ github.event.label.name }}"
          fi
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            echo "Comment event detected"
            echo "Comment body: ${{ github.event.comment.body }}"
          fi
      
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      
      - name: Parse mod submission
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body;
            
            // Parse the issue body to extract mod information
            const parseField = (fieldName) => {
              const regex = new RegExp(`### ${fieldName}\\s*([\\s\\S]*?)(?=###|$)`);
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };
            
            const modInfo = {
              name: parseField('Mod Name') || parseField('ModName'),
              version: parseField('Version'),
              description: parseField('Description'),
              author: parseField('Author'),
              tags: parseField('Tags'),
              requiredVersion: parseField('Required Palworld Version'),
              homepage: parseField('Homepage'),
              modDownloadUrl: parseField('Mod ZIP File Download URL'),
              iconDownloadUrl: parseField('Icon Download URL')
            };
            
            // Normalize required version to lowercase
            let requiredVersion = modInfo.requiredVersion.toLowerCase();
            if (requiredVersion.includes('game pass')) {
              requiredVersion = 'gamepass';
            } else if (requiredVersion.includes('steam')) {
              requiredVersion = 'steam';
            } else if (requiredVersion.includes('both')) {
              requiredVersion = 'both';
            }
            
            // Create folder name from mod name
            const folderName = modInfo.name.replace(/[^a-zA-Z0-9]/g, '');
            
            core.setOutput('mod-name', modInfo.name);
            core.setOutput('folder-name', folderName);
            core.setOutput('version', modInfo.version);
            core.setOutput('description', modInfo.description);
            core.setOutput('author', modInfo.author);
            core.setOutput('required-version', requiredVersion);
            core.setOutput('mod-download-url', modInfo.modDownloadUrl);
            core.setOutput('icon-download-url', modInfo.iconDownloadUrl);
            core.setOutput('issue-number', issue.number);
            
            return modInfo;
      
      - name: Create mod structure (manual approval)
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          # This would be triggered by a maintainer comment "/approve-mod"
          echo "üîß Creating mod structure for: ${{ steps.parse.outputs.mod-name }}"
          
          # Create mod directory
          mkdir -p "mods/${{ steps.parse.outputs.folder-name }}"
          
          # Generate UUID for the mod
          MOD_UUID=$(python3 -c "import uuid; print(str(uuid.uuid4()))")
          echo "üîë Generated UUID: $MOD_UUID"
          
          # Create mod-info.json with UUID
          cat > "mods/${{ steps.parse.outputs.folder-name }}/mod-info.json" << EOF
          {
            "UUID": "$MOD_UUID",
            "ModName": "${{ steps.parse.outputs.mod-name }}",
            "Version": "${{ steps.parse.outputs.version }}",
            "Description": "${{ steps.parse.outputs.description }}",
            "Author": "${{ steps.parse.outputs.author }}",
            "RequiredVersion": "${{ steps.parse.outputs.required-version }}",
            "Tags": ["pending"],
            "MinGameVersion": "0.3.0"
          }
          EOF
          
          echo "üìù Mod structure created."
      
      - name: Download mod files
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          MOD_FOLDER="mods/${{ steps.parse.outputs.folder-name }}"
          MOD_ZIP_URL="${{ steps.parse.outputs.mod-download-url }}"
          ICON_URL="${{ steps.parse.outputs.icon-download-url }}"
          
          echo "üì• Downloading mod files..."
          
          # Function to convert Google Drive URLs to direct download
          convert_gdrive_url() {
            local url="$1"
            
            # Check if it's a Google Drive URL
            if [[ "$url" == *"drive.google.com"* ]]; then
              echo "üîÑ Converting Google Drive URL to direct download..."
              
              # Extract file ID from various Google Drive URL formats
              FILE_ID=""
              if [[ "$url" == *"/file/d/"* ]]; then
                # Format: https://drive.google.com/file/d/FILE_ID/view?usp=sharing
                FILE_ID=$(echo "$url" | sed -n 's/.*\/file\/d\/\([^\/]*\).*/\1/p')
              elif [[ "$url" == *"id="* ]]; then
                # Format: https://drive.google.com/open?id=FILE_ID
                FILE_ID=$(echo "$url" | sed -n 's/.*id=\([^&]*\).*/\1/p')
              fi
              
              if [ ! -z "$FILE_ID" ]; then
                echo "üìÅ Google Drive File ID: $FILE_ID"
                echo "https://drive.google.com/uc?export=download&id=$FILE_ID"
              else
                echo "‚ö†Ô∏è Could not extract Google Drive file ID, using original URL"
                echo "$url"
              fi
            else
              echo "$url"
            fi
          }
          
          # Download mod ZIP file
          if [ ! -z "$MOD_ZIP_URL" ] && [ "$MOD_ZIP_URL" != "null" ]; then
            echo "Downloading mod ZIP from: $MOD_ZIP_URL"
            
            # Convert Google Drive URL if needed
            DOWNLOAD_URL=$(convert_gdrive_url "$MOD_ZIP_URL")
            echo "Using download URL: $DOWNLOAD_URL"
            
            # Extract filename from URL or create one
            ZIP_FILENAME=$(basename "$MOD_ZIP_URL")
            if [[ "$ZIP_FILENAME" != *.zip ]] || [[ "$ZIP_FILENAME" == *"?"* ]]; then
              ZIP_FILENAME="${{ steps.parse.outputs.folder-name }}-v${{ steps.parse.outputs.version }}.zip"
            fi
            
            echo "Saving as: $ZIP_FILENAME"
            
            # Check if it's a Google Drive URL and use appropriate method
            DOWNLOAD_SUCCESS=false
            
            if [[ "$MOD_ZIP_URL" == *"drive.google.com"* ]]; then
              echo "üîÑ Detected Google Drive URL, using specialized download method..."
              
              # Extract Google Drive file ID
              FILE_ID=""
              if [[ "$MOD_ZIP_URL" == *"/file/d/"* ]]; then
                FILE_ID=$(echo "$MOD_ZIP_URL" | sed -n 's/.*\/file\/d\/\([^\/]*\).*/\1/p')
              elif [[ "$MOD_ZIP_URL" == *"id="* ]]; then
                FILE_ID=$(echo "$MOD_ZIP_URL" | sed -n 's/.*id=\([^&]*\).*/\1/p')
              fi
              
              if [ ! -z "$FILE_ID" ]; then
                echo "üìÅ Google Drive File ID: $FILE_ID"
                
                # Install gdown for Google Drive downloads
                echo "üì¶ Installing gdown for Google Drive support..."
                pip install gdown --quiet || echo "‚ö†Ô∏è Failed to install gdown, falling back to wget"
                
                # Try gdown first (best for Google Drive)
                if command -v gdown &> /dev/null; then
                  echo "Using gdown for Google Drive download..."
                  if gdown "https://drive.google.com/uc?id=$FILE_ID" -O "$MOD_FOLDER/$ZIP_FILENAME" --quiet; then
                    DOWNLOAD_SUCCESS=true
                    echo "‚úÖ Downloaded successfully with gdown"
                  else
                    echo "‚ö†Ô∏è gdown failed, trying alternative method..."
                  fi
                fi
                
                # Fallback: Advanced wget method with proper Google Drive handling
                if [ "$DOWNLOAD_SUCCESS" = false ]; then
                  echo "Using advanced wget method for Google Drive..."
                  
                  # Create temporary directory for cookies
                  mkdir -p /tmp/gdrive_download
                  
                  # First request to get confirmation token
                  CONFIRM_TOKEN=$(wget --quiet --save-cookies /tmp/gdrive_download/cookies.txt \
                    --keep-session-cookies --no-check-certificate \
                    "https://docs.google.com/uc?export=download&id=$FILE_ID" \
                    -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\1\n/p' | head -n1)
                  
                  if [ ! -z "$CONFIRM_TOKEN" ]; then
                    echo "üîë Got confirmation token: $CONFIRM_TOKEN"
                    # Download with confirmation token
                    if wget --load-cookies /tmp/gdrive_download/cookies.txt \
                      "https://docs.google.com/uc?export=download&confirm=$CONFIRM_TOKEN&id=$FILE_ID" \
                      -O "$MOD_FOLDER/$ZIP_FILENAME" --quiet; then
                      DOWNLOAD_SUCCESS=true
                      echo "‚úÖ Downloaded successfully with wget + confirmation"
                    fi
                  else
                    # Try direct download (for smaller files)
                    echo "üîÑ Trying direct download..."
                    if wget "https://drive.google.com/uc?export=download&id=$FILE_ID" \
                      -O "$MOD_FOLDER/$ZIP_FILENAME" --quiet; then
                      DOWNLOAD_SUCCESS=true
                      echo "‚úÖ Downloaded successfully with direct wget"
                    fi
                  fi
                  
                  # Cleanup
                  rm -rf /tmp/gdrive_download
                fi
              fi
            else
              echo "üîÑ Regular URL detected, using standard download..."
              # Standard download for non-Google Drive URLs
              if command -v wget &> /dev/null; then
                wget -O "$MOD_FOLDER/$ZIP_FILENAME" "$DOWNLOAD_URL" --quiet && DOWNLOAD_SUCCESS=true
              elif command -v curl &> /dev/null; then
                curl -L -o "$MOD_FOLDER/$ZIP_FILENAME" "$DOWNLOAD_URL" --silent && DOWNLOAD_SUCCESS=true
              fi
            fi
            
            # Verify download
            if [ -f "$MOD_FOLDER/$ZIP_FILENAME" ]; then
              FILE_SIZE=$(stat -c%s "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null || stat -f%z "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null || echo "0")
              
              # Multiple checks for virus warning pages or failed downloads
              IS_VALID_FILE=true
              
              # Check 1: File size (virus warnings are typically small)
              if [ "$FILE_SIZE" -lt 5000 ]; then
                echo "‚ö†Ô∏è Downloaded file is very small ($FILE_SIZE bytes), checking content..."
                
                # Check 2: Look for HTML content (virus warnings are HTML pages)
                if file "$MOD_FOLDER/$ZIP_FILENAME" | grep -q "HTML"; then
                  echo "‚ùå Downloaded HTML page instead of ZIP file"
                  IS_VALID_FILE=false
                elif grep -q -i "virus\|warning\|google\|drive" "$MOD_FOLDER/$ZIP_FILENAME" 2>/dev/null; then
                  echo "‚ùå Downloaded virus warning page instead of ZIP file"
                  IS_VALID_FILE=false
                fi
              fi
              
              # Check 3: Try to verify it's actually a ZIP file
              if [ "$IS_VALID_FILE" = true ]; then
                if ! file "$MOD_FOLDER/$ZIP_FILENAME" | grep -q -i "zip\|archive"; then
                  echo "‚ö†Ô∏è File doesn't appear to be a valid ZIP archive"
                  # Don't mark as invalid yet, some ZIP files might not be detected properly
                fi
              fi
              
              if [ "$IS_VALID_FILE" = true ] && [ "$DOWNLOAD_SUCCESS" = true ]; then
                echo "‚úÖ Mod ZIP downloaded successfully ($FILE_SIZE bytes)"
              else
                echo "‚ùå Download failed - got virus warning or invalid file instead of ZIP"
                echo "üìù Recommendations for mod author:"
                echo "  ‚Ä¢ Upload to GitHub Releases (recommended)"
                echo "  ‚Ä¢ Use direct download links"
                echo "  ‚Ä¢ Avoid Google Drive for files >100MB"
                echo "  ‚Ä¢ Make sure sharing settings allow direct access"
                rm -f "$MOD_FOLDER/$ZIP_FILENAME"
              fi
            else
              echo "‚ùå Mod ZIP download failed - file not created"
            fi
          else
            echo "‚ö†Ô∏è No mod ZIP URL provided"
          fi
          
          # Download icon file
          if [ ! -z "$ICON_URL" ] && [ "$ICON_URL" != "null" ]; then
            echo "Downloading icon from: $ICON_URL"
            
            # Convert Google Drive URL if needed
            ICON_DOWNLOAD_URL=$(convert_gdrive_url "$ICON_URL")
            
            # Detect extension from URL
            ICON_EXT="png"
            if [[ "$ICON_URL" =~ \.(jpg|jpeg|png|gif|webp)(\?|$) ]]; then
              ICON_EXT=$(echo "$ICON_URL" | sed -n 's/.*\.\(jpg\|jpeg\|png\|gif\|webp\).*/\1/p')
            fi
            ICON_FILENAME="icon.$ICON_EXT"
            
            echo "Saving icon as: $ICON_FILENAME"
            
            # Download icon with headers to handle various image hosting sites
            ICON_SUCCESS=false
            if command -v wget &> /dev/null; then
              # Use wget with user agent and referrer for sites like NexusMods
              if wget --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
                     --no-check-certificate \
                     --timeout=30 \
                     -O "$MOD_FOLDER/$ICON_FILENAME" \
                     "$ICON_DOWNLOAD_URL" 2>/dev/null; then
                ICON_SUCCESS=true
              fi
            elif command -v curl &> /dev/null; then
              # Fallback to curl with similar headers
              if curl -L \
                     -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
                     --max-time 30 \
                     -o "$MOD_FOLDER/$ICON_FILENAME" \
                     "$ICON_DOWNLOAD_URL" 2>/dev/null; then
                ICON_SUCCESS=true
              fi
            fi
            
            # Verify icon download
            if [ -f "$MOD_FOLDER/$ICON_FILENAME" ]; then
              ICON_SIZE=$(stat -c%s "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null || stat -f%z "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null || echo "0")
              
              # Check if it's actually an image file
              IS_VALID_IMAGE=true
              FILE_TYPE=$(file -b --mime-type "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null || echo "unknown")
              
              # Check 1: File size (too small is likely an error page)
              if [ "$ICON_SIZE" -lt 500 ]; then
                echo "‚ö†Ô∏è Downloaded icon is very small ($ICON_SIZE bytes), likely not a valid image"
                IS_VALID_IMAGE=false
              fi
              
              # Check 2: Verify it's an image MIME type
              if ! echo "$FILE_TYPE" | grep -q "image"; then
                echo "‚ö†Ô∏è Downloaded file is not an image (type: $FILE_TYPE)"
                IS_VALID_IMAGE=false
              fi
              
              # Check 3: Look for HTML content (error pages)
              if grep -q -i "<html\|<!DOCTYPE" "$MOD_FOLDER/$ICON_FILENAME" 2>/dev/null; then
                echo "‚ö†Ô∏è Downloaded HTML page instead of image"
                IS_VALID_IMAGE=false
              fi
              
              if [ "$IS_VALID_IMAGE" = true ] && [ "$ICON_SUCCESS" = true ]; then
                echo "‚úÖ Icon downloaded successfully ($ICON_SIZE bytes, type: $FILE_TYPE)"
              else
                echo "‚ö†Ô∏è Icon download failed or invalid (optional file). Removing invalid file."
                rm -f "$MOD_FOLDER/$ICON_FILENAME"
              fi
            else
              echo "‚ö†Ô∏è Icon download failed (optional file)"
            fi
          else
            echo "‚ÑπÔ∏è No icon URL provided (optional)"
          fi
          
          echo "üìÅ Download process completed"
      
      - name: Commit mod structure
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Bot"
          git config --local advice.addIgnoredFile false
          git add -f "mods/${{ steps.parse.outputs.folder-name }}/"
          git commit -m "‚úÖ Add approved mod with files: ${{ steps.parse.outputs.mod-name }} v${{ steps.parse.outputs.version }} (Issue #${{ steps.parse.outputs.issue-number }})"
          git push
          echo "üöÄ Mod structure committed and pushed to repository"
      
      - name: Update manifest
        if: contains(github.event.comment.body, '/approve-mod')
        run: |
          echo "üîÑ Updating manifest with new mod..."
          python scripts/generate-manifest.py
          
          # Check if manifest changed
          if git diff --quiet manifest.json; then
            echo "‚ÑπÔ∏è No manifest changes needed"
          else
            echo "üìù Manifest updated, committing changes..."
            git add manifest.json
            git commit -m "ü§ñ Auto-update manifest after adding ${{ steps.parse.outputs.mod-name }}"
            git push
            echo "‚úÖ Manifest updated and pushed"
          fi
      
      - name: Add approval comment
        if: contains(github.event.comment.body, '/approve-mod')
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚úÖ **Mod Approved and Fully Processed!**
              
              **${{ steps.parse.outputs.mod-name }}** has been approved and automatically added to the mod store!
              
              **üìÅ Mod Location:** \`mods/${{ steps.parse.outputs.folder-name }}/\`
              
              **üì• Files Downloaded:**
              - ‚úÖ Mod metadata (mod-info.json)
              - üì¶ Mod ZIP file (automatically downloaded)
              - üñºÔ∏è Icon file (if provided)
              
              **Next Steps:**
              1. üîÑ Manifest will be updated automatically
              2. ‚úÖ Mod will be available in mod managers within 15 minutes
              3. üéâ Users can now download and install your mod!
              
              **Download URLs used:**
              - **Mod ZIP:** ${{ steps.parse.outputs.mod-download-url }}
              - **Icon:** ${{ steps.parse.outputs.icon-download-url }}
              
              Your mod is now live in the PalSchema Mod Store! Thank you for contributing! üöÄ`
            });
      
      - name: Close issue after successful processing
        if: contains(github.event.comment.body, '/approve-mod')
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              state_reason: 'completed'
            });
            console.log('Issue closed successfully after mod approval');
      
      - name: Add processing comment
        if: github.event_name == 'issues' && github.event.action == 'opened'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üéÆ **Mod Submission Received!**
              
              Thank you for submitting **${{ steps.parse.outputs.mod-name }}** to the PalSchema Mod Store!
              
              **Next Steps:**
              1. üîç Our team will review your submission
              2. üß™ We'll test the mod for compatibility and safety
              3. ‚úÖ If approved, your mod will be added to the store
              
              **For Maintainers:**
              - Review the mod details above
              - Download and test the mod files:
                - **Mod ZIP:** ${{ steps.parse.outputs.mod-download-url }}
                - **Icon:** ${{ steps.parse.outputs.icon-download-url }}
              - Comment \`/approve-mod\` to process this submission
              - Comment \`/reject-mod [reason]\` to reject with explanation
              
              **Estimated Review Time:** 2-5 business days
              
              **üìù Note for large files:** If using Google Drive, large files may trigger virus warnings that prevent automatic download. For best results, consider using:
              - GitHub Releases (recommended)
              - Direct links from your own server
              - Other file hosting services with direct download support
              
              We'll keep you updated on the status! üöÄ`
            });
      
      - name: Handle rejection
        if: contains(github.event.comment.body, '/reject-mod')
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const reason = comment.replace('/reject-mod', '').trim();
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚ùå **Mod Submission Rejected**
              
              Unfortunately, we cannot accept **${{ steps.parse.outputs.mod-name }}** at this time.
              
              **Reason:** ${reason || 'No reason provided'}
              
              **What you can do:**
              - Address the issues mentioned above
              - Submit a new mod submission with the fixes
              - Join our Discord for help and discussion
              
              Thank you for your contribution! üôè`
            });
            
            // Close the issue
            github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: ['mod-submission', 'rejected']
            });
